"""
1.因為Race condition,在第一個thread做完+1之前thread2就已經和同樣的data做請求並複製值
假設程序中有一個data值是10:

time ----->

thread1:  10 -----> 10+1=11 ----->    11
        (讀取)                         |
thread2:  |      10 -----> 10+1=11     |    ----->   11 
          |     (讀取)               (寫入)          (寫入)
data:     10     10                  10->11         11->11

理論上應算出12  可是實際上跑完的程序是11

2.因為numpy在做的時候已經考慮到了race condition 的問題 所以自建Lock
3.因為全部都被lock住了
"""